\textbf{\large Результаты}

\begin{enumerate}

\item Замеры времени работы ядер с различными конфигурациями (время указано в микросекундах).

\begin{tabular}{|c|c|c|c|c|c|}\hline
\diaghead{\theadfont Diag ColumnmnHead II}%
{Конфи-\\гурации ядра}{Размер мат-\\ рицы}&
\thead{10x10}&\thead{100x100}&\thead{500x500}&\thead{1500x1500}&\thead{3000x3000}\\
\hline
1, 32 & 489 & 6 256 & 68 161 & 691 531 & 5 124 627\\
\hline
32, 32 & 492 & 5 761 & 53 164 & 603 206 & 4 622 832\\
\hline
32, 256 & 491 & 5 869 & 54 139 & 602 148 & 4 619 617\\
\hline
256, 256 & 496 & 5 876 & 54 690 & 599 696 & 4 619 521\\
\hline
1024, 1024 & 809 & 9 554 & 70 408 & 624 864 & 4 646 478\\
\hline
\end{tabular}

\item Сравнение с CPU

\begin{tabular}{|c|c|c|c|c|c|}\hline
Размер входных данных &
\thead{10x10}&\thead{100x100}&\thead{500x500}&\thead{1500x1500}&\thead{3000x3000}\\
\hline
GPU(256, 256) & 496 & 5 876 & 54 690 & 599 696 & 4 619 521\\
\hline
CPU & 7 & 5 539 & 604 241 & 16 961 677 & 135 534 879\\
\hline
\end{tabular}

\item nv-nsight-cu-cli

Для сравнения скорости обращения к глобальной памяти с объединением запросов и без были реализована версия функции $iteration$ с обращением к элементам по столбцам и по строкам.

Количество обращений к глобальной памяти при обращении к элементам:

\begin{tabular}{|c|c|c|c|}\hline
&\thead{10x10}&\thead{100x100}&\thead{500x500}\\
\hline
по столбцам & 5 568 & 2 522 660 & 634 312 088\\
\hline
по строкам & 1 402 & 687 050 & 157 250 144\\
\hline
\end{tabular}

Как видно по результатам, при обращении к элементам по строкам количество обращений к глобальной памяти меньше в 4 раза.

\end{enumerate}

