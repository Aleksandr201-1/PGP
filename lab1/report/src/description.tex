\textbf{\large Описание программы}

Для того, чтобы поэлементно найти максимумы двух векторов, необходимо создать вектор $arrays$ длины $2n$ на $device$ и заполнить его элементами первого и второго вектора. Для этого я создал 2 вектора на $host$ и скопировал их на $device$ при помощи функции $cudaMemcpy$ и передал в $kernel$. В функции $kernel$ идёт сравнение элементов $i$ и $i + n$, после чего максимум записывается на место $i$. После работы $kernel$ я скопировал результат в выходной вектор с помощью аналогичной функции и вывел результат на экран.

Вызов $kernel$ происходит с количеством нитей на блок ~--- 1024 и количеством блоков ~--- 1024.
В самом $kernel$ я вычисляю общий индекс исполняемой нити $idx$ который и будет индексом в массиве при условии $idx < n$, где $n$ ~--- размер векторов, и смещение $offset$, которое позволяет найти следующий обрабатываемый элемент для нити.

Аргумент $count\_of\_arrays$ нужен для указания количества векторов для нахождения максимума, так как в моей реализации поэлементный максимум может находиться для произвольного количества векторов (для задания этот аргумент всегда будет равен двум).

Код функции:

\begin{lstlisting}[basicstyle=\normalfont, language=C++]
__global__ void kernel (double *arrays, int count_of_arrays, int n) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    int offset = blockDim.x * gridDim.x;
    double tmp;
    while (idx < n) {
        tmp = arrays[idx];
        for (int i = 1; i < count_of_arrays; ++i) {
            tmp = max(tmp, arrays[idx + i * n]);
        }
        arrays[idx] = tmp;
        idx += offset;
    }
}
\end{lstlisting}

\vspace{15pt}

